{"name":"Sally","tagline":"A model checker for infinite-state systems.","body":"Sally is a model checker for infinite state systems described as transition \r\nsystems. It is research software under development so the features and the \r\ninput language may change rapidly.   \r\n\r\nThe project is supported by NASA contract NNX14AI05A.\r\n\r\n## Prerequisites\r\n\r\nIn order to compile Sally you will need a reasonable c++ compiler such as g++ or clang, the cmake build system, the GMP library, some boost libraries, and a working Java runtime (for parser generation). On Ubuntu-like systems, the following should cover it:\r\n\r\n    sudo apt-get install g++\r\n    sudo apt-get install cmake\r\n    sudo apt-get install libgmp-dev\r\n    sudo apt-get install libboost-program-options-dev libboost-iostreams-dev libboost-test-dev libboost-thread-dev libboost-system-dev\r\n    sudo apt-get install default-jre\r\n\r\nIn addition, Sally needs an SMT solver for reasoning about the systems. It currently supports [Yices2](http://yices.csl.sri.com/) and [MathSAT5](http://mathsat.fbk.eu/), and for best results we recommend using both of them. \r\n\r\n## How to Compile\r\n\r\nIf you have Yices2 installed in the $YD directory, meaning that there are \r\n$YD/include and $YD/lib directories with Yices2 headers and libraries, then\r\nconfigure and build with \r\n\r\n    cd build\r\n    cmake .. -DYICES2_HOME=$YD\r\n    make\r\n    make check\r\n\r\nIf you have MathSAT5 installed in the $MD directory, meaning that there are \r\n$MD/include and $MD/lib directories with MathSAT5 headers and libraries, then \r\nconfigure and build with\r\n\r\n    cd build\r\n    cmake .. -DMATHSAT5_HOME=$MD\r\n    make\r\n    make check\r\n   \r\nOf course, you can use both Yices2 and MathSAT by adding both options to \r\ncmake as expected.\r\n\r\nTo compile sally in debug mode then configure and build with\r\n\r\n    cd build\r\n    cmake .. -DCMAKE_BUILD_TYPE=Debug\r\n    make\r\n    make check\r\n\r\n### Input Language\r\n\r\n#### Transition System Definition \r\n\r\nSally takes as input a simple description of transition systems based on the \r\nSMT2 language. A transition system consists of a description of the state type, \r\na formula describing the initial states of the system, and a formula describing \r\nthe transitions from the current to the next state of the system.\r\n\r\nState type is a list of variables that are part of the state, together with\r\ntheir types.\r\n```lisp\r\n;; A definition of a state type called \"my_state_type\" with variables\r\n;; x and y of type Real. \r\n(define-state-type my_state_type \r\n  ((x Real) (y Real))\r\n)\r\n```\r\nWith a defined state type, we can define sets of states and transitions over the\r\nstate type.\r\n\r\nWe can describe a set of states with a state formula over the state type. A \r\nstate formula is a first-order formula over the variables of the state type, \r\nwritten in SMT2 format.\r\n```lisp\r\n;; Definition of a set of states \"x_is_zero\" capturing all states \r\n;; over the state type \"my_state_type\" where x is 0.\r\n(define-states x_is_zero my_state_type\r\n  (= x 0)\r\n)\r\n```\r\nOnce a state formula has been defined it can be reused in other state formulas\r\nover the same state type.\r\n```lisp\r\n;; A definition of a set of states \"initial_states\" over \r\n;; \"my_state_type\" by a state formula. These are all states where \r\n;; both x and y are 0.\r\n(define-states initial_states my_state_type\r\n  (and x_is_zero (= y 0))\r\n)\r\n```   \r\nWe can describe allowed state transitions by a first-order formula over the \r\ncurrent (state) and next variables of the state type. We use the prefix\r\n``state`` to denote current variables, and the prefix ``next`` to denote the \r\nvariables in the next state. Previously defined state formulas over the same\r\nstate type can be used as if they were variables (state or next). Similarly, \r\npreviously defined transitions over the same type can be used directly. \r\n```lisp\r\n;; Definition of a transition where the next value of x is the \r\n;; current value + 1.\r\n(define-transition inc_x my_state_type\r\n  (= next.x (+ state.x 1))\r\n)   \r\n    \r\n;; Definition of a transition that increases both x and y\r\n(define-transition inc_x_and_y my_state_type\r\n  (and inc_x (= next.y (+ state.y 1)))\r\n)\r\n    \r\n;; Definition of a transition that increases x and y if not \r\n;; exceeding 100, or goes back to the state with x = y = 0\r\n(define-transition transition my_state_type\r\n  (or \r\n    (and (< state.x 100) inc_x_and_y)\r\n    next.initial_states\r\n  ) \r\n)\r\n```\r\nWe can define a state transition system by defining the state type, the initial\r\nstates of the system and the transitions that the system can make.\r\n```lisp\r\n;; Directly define a simple counter system that increases x and y\r\n(define-transition-system T1 my_state_type\r\n  ;; Initial states \r\n  (and (= x 0) (= y 0))\r\n  ;; Transition \r\n  (and (= next.x (+ state.x 1)) (= next.y (+ state.y 1)))\r\n)\r\n    \r\n;; Define the counter system that can reset to 0 by reusing defined\r\n;; formulas \r\n(define-transition-system T2 my_state_type\r\n   ;; Initial states\r\n   initial_states\r\n   ;; Transitions \r\n   transition\r\n)\r\n```\r\n\r\n#### Queries\r\n\r\nA query asks a question whether a state property is true in the given transition \r\nsystem. For example, in the system ``T1``, it is clear that we the \r\nvariables ``x`` and ``y`` will always be equal and non-negative. We can check \r\nthese with the following queries.\r\n```lisp\r\n;; Check whether x = y in T1\r\n(query T1 (= x y))\r\n\r\n;; Check whether x, y >= 0\r\n(query T1 (and (>= x 0) (>= y 0)))\r\n```\r\n\r\nIn the system ``T2``, it should hold that both ``x`` and ``y`` will never \r\nexceed 20. \r\n```lisp\r\n;; Check whether x, y <= 20\r\n(query T2 (and (<= x 20) (<= y 20)))\r\n    \r\n;; Check whether x, y <= 19\r\n(query T2 (and (<= x 19) (<= y 19)))\r\n```\r\n\r\nThe example above is available in ``examples/example.mcmt``.\r\n    \r\n### Usage \r\n\r\nTo see the full set of options run ``sally -h``. Some typical examples are as \r\nfollows\r\n\r\n* Checking the properties with the bounded model-checking (BMC) engine\r\n```bash\r\n> sally --engine bmc examples/example.mcmt\r\nunknown\r\nunknown\r\nunknown\r\nunknown\r\n```\r\n    \r\n* Checking the property with BMC with a bigger bound and showing any \r\ncounter-example traces\r\n```bash\r\n> sally --engine bmc --bmc-max 20 --show-trace examples/example.mcmt\r\nunknown\r\nunknown\r\nunknown\r\ninvalid\r\n(trace \r\n  (frame (x 0) (y 0))\r\n  (frame (x 1) (y 1))\r\n  ...\r\n  (frame (x 20) (y 20))\r\n)\r\n```\r\n    \r\n* Checking the properties with the k-induction engine\r\n```bash\r\n> sally --engine kind examples/example.mcmt\r\nvalid\r\nvalid\r\nunknown\r\nunknown \r\n> sally --engine kind --kind-max 20 examples/example.mcmt \r\nvalid\r\nvalid\r\nunknown\r\ninvalid\r\n```\r\n    \r\n* Checking the properties with the ic3 engine using the combination of yices2\r\n  and MathSAT5 as the reasoning engine\r\n```bash\r\n> sally --engine ic3 --solver y2m5 examples/example.mcmt \r\nvalid\r\nvalid\r\nvalid\r\ninvalid\r\n```\r\n","google":"UA-73180810-1","note":"Don't delete this file! It's used internally to help with page regeneration."}